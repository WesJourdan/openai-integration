import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import apiUtils from '../../global/utils/api';
import { convertListToMap, shouldFetch } from '../../global/utils/storeUtils';


const initialState = {
  /**
   * "byId" is an object map of all product items in the store. The map's keys are
   * the Mongo ids of the objects by default
   */
  byId: {}
  
  /**
   * "queries" is an object map of all server fetches for products. The map's keys are listArgs
   * in the case of list fetches and Mongo ids in the case of single fetches.
   * Each individual query looks like this:
   * 
   * @example {
   *  expirationDate: date
   *  receivedAt: date
   *  status: 'pending' || 'fulfilled' || 'rejected'
   *  // for lists
   *  ids: [mongoId, mongoId]
   *  // for singles
   *  id: mongoId
   * }
   */
  , singleQueries: {}
  , listQueries: {}

};

/**
 * The function below is called a thunk and allows us to perform async logic. It
 * can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
 * will call the thunk with the `dispatch` function as the first argument. Async
 * code can then be executed and other actions can be dispatched. Thunks are
 * typically used to make async requests.
 * 
 * In practice we won't dispatch these directly, they will be dispatched by productService which has a nicer api built on hooks.
 */

// CREATE
export const sendCreateProduct = createAsyncThunk(
  'product2/sendCreate',
  async (newProduct) => {
    const endpoint = `/api/products`;
    const response = await apiUtils.callAPI(endpoint, 'POST', newProduct);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// READ
export const fetchDefaultProduct = createAsyncThunk(
  'product2/fetchDefault',
  async () => {
    const endpoint = `/api/products/default`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const fetchSingleProduct = createAsyncThunk(
  'product2/fetchSingle',
  async (id) => {
    const endpoint = `/api/products/${id}`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const fetchProductList = createAsyncThunk(
  'product2/fetchList', // this is the action name that will show up in the console logger.
  async (listArgs) => {
    const endpoint = `/api/products?${listArgs}`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// UPDATE
export const sendUpdateProduct = createAsyncThunk(
  'product2/sendUpdate',
  async ({_id, ...updates}) => {
    const endpoint = `/api/products/${_id}`;
    const response = await apiUtils.callAPI(endpoint, 'PUT', updates);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// TODO: add sendDeleteProduct


// define the productSlice. This is a combination of actions and reducers. More info: https://redux-toolkit.js.org/api/createSlice
export const productSlice = createSlice({
  name: 'product',
  initialState,
  /**
   * The `reducers` field lets us define reducers and generate associated actions.
   * Unlike the selectors defined at the bottom of this file, reducers only have access
   * to this specific reducer and not the entire store.
   * 
   * Again, we will not dispatch these directly, they will be dispatched by productService.
   */
  reducers: {
    invalidateQuery: (state, action) => {
      const queryKey = action.payload;
      const query = state.listQueries[queryKey] || state.singleQueries[queryKey];
      if(query) query.didInvalidate = true
    }
    , addProductToList: (state, action) => {
      const { queryKey, id } = action.payload;
      const query = state.listQueries[queryKey];
      if(query) {
        query.ids.push(id)
      } else {
        console.log('Could not find list');
      }
    }
  },

  /**
   * The `extraReducers` field lets the slice handle actions defined elsewhere,
   * including actions generated by createAsyncThunk or in other slices.
   * We'll use them to track our server request status.
   */
  extraReducers: (builder) => {
    builder
      // CREATE
      .addCase(sendCreateProduct.fulfilled, (state, action) => {
        // console.log('action', action);
        const product = action.payload;
        // add it to the map
        state.byId[product._id] = product;
        // create a query object for it
        state.singleQueries[product._id] = {
          id: product._id
          , status: 'fulfilled'
          , receivedAt: Date.now()
          , expirationDate: Date.now() + (1000 * 60 * 5) // 5 minutes from now
        }

        // A new product was just created. Rather than dealing with adding it to a list or invalidating specific lists from the component we'll just invalidate the listQueries here.
        Object.keys(state.listQueries).forEach(queryKey => {
          state.listQueries[queryKey].didInvalidate = true;
        });
      })
      .addCase(sendCreateProduct.rejected, (state, action) => {
        // TODO: handle server errors
      })

      // READ
      .addCase(fetchDefaultProduct.pending, (state, action) => {
        // create a query object for it in the queries map
        state.singleQueries['defaultProduct'] = {
          id: 'defaultProduct'
          , status: 'pending'
        };
      })
      .addCase(fetchDefaultProduct.fulfilled, (state, action) => {
        const defaultProduct = action.payload;
        // add it to the byId map (for the id we'll use 'defaultProduct')
        state.byId['defaultProduct'] = defaultProduct
        // state.byId = { ...state.byId, defaultProduct: defaultProduct };
        // update the query object
        const singleQuery = state.singleQueries['defaultProduct'];
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Infinity; // this should never expire. It's just an empty product.
      })
      .addCase(fetchDefaultProduct.rejected, (state, action) => {
        const singleQuery = state.singleQueries['defaultProduct'];
        singleQuery.status = 'rejected';
        singleQuery.receivedAt = Date.now();
      })
      .addCase(fetchSingleProduct.pending, (state, action) => {
        // update or create a query object for it in the queries map
        state.singleQueries[action.meta.arg] = { ...state.singleQueries[action.meta.arg], id: action.meta.arg, status: 'pending', didInvalidate: false };
      })
      .addCase(fetchSingleProduct.fulfilled, (state, action) => {
        const product = action.payload;
        // add the product object to the byId map
        state.byId[product._id] = product;
        // find the query object for this fetch in the singleQueries map and update query info
        const singleQuery = state.singleQueries[action.meta.arg];
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(fetchSingleProduct.rejected, (state, action) => {
        // find the query object for this fetch in the singleQueries map and update query info
        const singleQuery = state.singleQueries[action.meta.arg];
        singleQuery.status = 'rejected';
        singleQuery.receivedAt = Date.now();
      })
      .addCase(fetchProductList.pending, (state, action) => {
        // update or create the query object for it in the listQueries map
        state.listQueries[action.meta.arg] = { ...state.listQueries[action.meta.arg], status: 'pending', didInvalidate: false };
      })
      .addCase(fetchProductList.fulfilled, (state, action) => {
        const { products, totalPages } = action.payload;
        // update list query
        // convert the array of objects to a map
        const productMap = convertListToMap(products, '_id');
        // add the product objects to the byId map
        state.byId = { ...state.byId, ...productMap };

        // find the query object for this fetch in the listQueries map and update query info
        const listQuery = state.listQueries[action.meta.arg];
        // save the array of ids for the returned products
        listQuery.ids = products.map(product => product._id);
        // set the rest of the query info
        listQuery.totalPages = totalPages;
        listQuery.status = 'fulfilled';
        listQuery.receivedAt = Date.now();
        listQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now

        // while we're here we might as well add a single query for each of these since we know they're fresh
        products.forEach(product => {
          // add a single query for the product.
          const singleQuery = {
            id: product._id
            , status: listQuery.status
            , receivedAt: listQuery.receivedAt
            , expirationDate: listQuery.expirationDate
          };
          state.singleQueries[product._id] = singleQuery;
        });
      })
      .addCase(fetchProductList.rejected, (state, action) => {
        // TODO: handle server errors
        const listQuery = state.listQueries[action.meta.arg];
        listQuery.status = 'rejected';
        listQuery.receivedAt = Date.now();
      })
      
      // UPDATE
      .addCase(sendUpdateProduct.pending, (state, action) => {
        // action.meta.arg in this case is the updated product object that was sent in the POST
        const updatedProduct = action.meta.arg
        // get the product id
        const id = updatedProduct._id;
        // access or create the query object in the map
        state.singleQueries[id] = { ...state.singleQueries[id], id: id, status: 'pending' }

        // optimistic update the version that's in the map
        state.byId[id] = { ...state.byId[id], ...updatedProduct}
      })
      .addCase(sendUpdateProduct.fulfilled, (state, action) => {
        const product = action.payload;
        // replace the previous version in the map with the new one
        state.byId[product._id] = product;
        // update the query object
        const singleQuery = state.singleQueries[product._id];
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(sendUpdateProduct.rejected, (state, action) => {
        // action.meta.arg in this case is the updated product object that was sent in the POST
        const product = action.meta.arg
        // update the query object
        const singleQuery = state.singleQueries[product._id];
        singleQuery.status = 'rejected';
        singleQuery.receivedAt = Date.now();
      })
    // TODO: add delete
  },
});

export const { invalidateQuery, addProductToList } = productSlice.actions;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const fetchListIfNeeded = (queryKey) => (dispatch, getState) => {
  const productQuery = getState().product2.listQueries[queryKey];
  if(shouldFetch(productQuery)) {
    // console.log('Fetching new product list', );
    dispatch(fetchProductList(queryKey));
  } else {
    // console.log('No need to fetch, fresh query in cache');
  }
};

/**
 * The functions below are called a selectors and allow us to select a value from
 * the store. Selectors can also be defined inline where they're used instead of
 * in the slice file. For example: `useSelector((store: RootState) => store.product.value)`
 * 
 * These are the replacement for the old mapStoreToProps functionality.
 * 
 * Because selectors take the whole store as their first argument, and our
 * stores are all structured the same way, we could define these at the global
 * level and pass in the store we want to access when we use them.
 * 
 * for example in productService:
 * 
 * const singleProduct = useSelector(store => selectSingleById(store.product, productId))
 * 
 * But to minimize the risk of over-generalizing, we'll define a set in each store.
 */


/**
 * 
 * @param {object} productStore - supplied by useSelector hook
 * @param {string} queryKey - the key used to access the query from the map
 * @returns 
 */
export const selectListItems = ({product2: productStore}, queryKey) => {
  const listIds = productStore.listQueries[queryKey]?.ids;
  if(listIds) {
    return listIds.map(id => productStore.byId[id]);
  } else {
    return null;
  }
}

export const selectListPageCount = ({product2: productStore}, listArgs) => {
  return productStore.listQueries[listArgs]?.totalPages;
}

export const selectShouldFetch = ({ product2: productStore }, queryKey) => {
  if(!queryKey) return false;
  const productQuery = productStore.listQueries[queryKey] || productStore.singleQueries[queryKey];
  // use the util to check if we should fetch or not
  return shouldFetch(productQuery);
}


export const selectSingleById = ({product2: productStore}, id) => {
  return productStore.byId[id];
}

// export const selectFetchStatus = ({ product2: productStore }, queryKey) => {
//   const productQuery = productStore.listQueries[queryKey] || productStore.singleQueries[queryKey];
//   return productQuery?.status;
// }

export const selectQuery = ({ product2: productStore }, queryKey) => {
  const productQuery = productStore.listQueries[queryKey] || productStore.singleQueries[queryKey];
  return productQuery || {};
}

export default productSlice.reducer;
